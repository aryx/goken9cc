\documentclass{article}
%CONFIG:
%\usepackage{fullpage}

\input{../../principia/docs/latex/Packages}

%alt: \input{../latex/Noweb}
\usepackage{../../principia/docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../../principia/docs/latex/syncweb}

\newif\iffinal\newif\ifverbose\newif\ifallcode
\input{../../principia/docs/latex/Macros}

\title{
\goken: The Plan 9 Toolchain Reborn
}
\author{
Yoann Padioleau\\
yoann.padioleau@gmail.com
}

\begin{document}
\date{}
\maketitle

\begin{abstract}
\goken is a work-in-progress project that aims to unify, in a single repository
(\url{https://github.com/aryx/goken9cc}),
the many improvements made to the original \plan toolchain.
The goal is to provide
assemblers, linkers, and C compilers for modern architectures, capable
of producing binaries not only for \plan but also Linux, macOS, and Windows.
\end{abstract}


\section{Introduction}

The \plan designers didn't just rethink from scratch the kernel;
they rethinked the whole operating system (OS) in a holistic manner.
%
In particular, the \plan assemblers, linkers, and C compilers, 
% with an 's' because many archs and separate progs
forming what is commonly called a {\em toolchain}, were also
written from scratch, by none other than Ken Thompson.
%
The design of this toolchain was also original with
the machine-code generation part shifted from the assembler to the linker,
%to factorize code? to simplify?
%% later though Rob Pike said it was maybe a mistake.
a C preprocessor embedded in the C compiler to speedup compilation time,
% also embedded in assembler
% cpp, a common complaint from Pike, leading later to Go
the support for numerous architectures (x86, Mips, ARM, Sparc, etc.),
and the ability to easily cross compile for those architectures
partly thanks to a clever naming scheme.
%alt:, and more?


In \plan, each architecture is assigned a character: x86 is '8', Mips
is 'v', ARM is '5', etc. To produce ARM binaries, one can simply
call [[5a]], the ARM assembler, to produce [[.5]] object
files (not [[.o]]), which can be linked by [[5l]], the ARM linker, to
produce a [[5.out]] binary (not [[a.out]]).
%
To produce x86 binaries use instead [[8a]] and [[8l]] in the same
directory without fear of overwriting the previous ARM object files
as this time the object files will use the [[.8]] extension.
% (cross compiling, now popularized by ziglang).
% always supported by gcc, but never made easy (less needed too it's true)
%
In the following, I use the name {\em Kencc} to denote the set of 
assemblers, linkers, and C compilers supporting the many
architectures in the original \plan.

Kencc has a simple and very small codebase, which made
it very easy for other people to add support for more architectures.
% cite article, and people did add!
%said-later: Miller added, Forsity added
%
For example, the number of lines of code (LOC) of the ARM
assembler [[5a]] is 3600, the ARM linker [[5l]] is 7500 LOC, and the
C compiler [[5l]] with the architecture-independent code plus ARM-specific
code is only 18500 LOC. The whole ARM toolchain is less than 30000 LOC in total;
this is incredibly small compared to
the LOC of [[gcc]]/binutils or [[clang]]/LLVM.
% which are? only arm-xxx.c is 60000 ? and just arm-specific part,
% See Compiler.nw, Assembler.nw, and Linker.nw to put the LOC
% of ARM specific stuff

\section{Kencc after \plan}

After \plan 4th edition in 2000, Kencc continued to evolve and has been forked
many times.
%
Charles Forsyth added support for the arm64
architecture (architecture character '7'), which
powers all recent Apple machines as well as the Raspberry Pi 3 and 4.
%
Richard Miller added support for the RISC-V architecture,
both the 32 and 64 bits variants,
with respectively characters 'i' and 'j'.
% put dates? Miller in 2017?

The Inferno developers removed the use of \plan-specific C extensions
in the Kencc code in exchange for the ability to compile Kencc itself
using [[gcc]] or [[clang]], so one could install and use Kencc
on Linux, macOS, and Windows (but only to link \plan binaries).
% help for bootstrap


Finally, the Go designers, which include Rob Pike, designer of
\plan and author of the \plan assemblers and linkers, and
Ken Thompson, designer of \unix, \plan, and author of the \plan
C compilers, used and extended Kencc to write the 
original Go compiler.
%
Up until Go 1.3, the Go repository contained the C code of the
[[5a/5c/5l]] (ARM), [[8a/8c/8l]] (x86), and [[6a/6c/6l]] (amd64)
toolchains.
%
They extended Kencc to not only link \plan{} [[a.out]] binaries
but also Linux [[ELF]] binaries, macOS [[Mach-O]] binaries, and
even Windows [[PE]] binaries.
%
They also developed a minimalist C and assembly library to interact
with the system calls of Linux, macOS, and Windows, so the Go
toolchain could produce Go binaries that could run on those 3 OSes.
%Unfortunately disappeared, or spread around. Enter Goken!

\section{The \goken project}

The goal of the new \goken project is to consolidate, in a 
single repository (\url{https://github.com/aryx/goken9cc}),
the many improvements made to the \plan toolchain over
the past two decades.
%
The \goken toolchain should
{\em cross-compile} for modern architectures (arm64, amd64, RISC-V),
{\em build} on those modern architectures, 
{\em build} on \plan but also Linux, macOS, and Windows, 
and finally {\em link} binaries that can run on those four OSes.
%
For example, you should be able to install Goken on an arm64 macOS 
machine and use it to produce binaries for a RISC-V Linux machine.

The goal is to provide a viable alternative to
[[gcc]]/binutils  and [[clang]]/LLVM with a
codebase that is only a fraction of their size.
%doable, the golang developers did it for Go!

\section{Current state}


% Life after plan9, it evolved (see next section). Was actually used
% to bootstrap golang! The 6/8/5 assemblers/linkers/compilers were
% in go repo until 1.3 and gradually got converted to Go.
% When in Go kencc got good improvements when used
% inside golang (Elf Linux, Mach-o macos, PE windows, dwarf gdb)!
% In fact hidden inside golang is this gem
% with multi-arch AND multi-os!! can cross compile on 386 Linux
% a macos amd64 binary! or windows! with minilibc! statically!
% (again now popularized with ziglang, golang).
% Unfortunately disappeared. Hidden gem!
% And got forked and mostly lost.
% Sad because fantastic toolchain; actually I got trouble
% cross compiling xv6 on my machine with gcc/binutils!

% Time to offer a real alternative to gcc/binutils and clang/llvm/lld!
% Lots of efforts on linker (mold, ...) but again time to go back
% to simplicity! and re-expose this hidden plan9 and inferno and golang gem!!
 
%TOC:
% - kencc history?
% - kencc fork history
%   plan9, inferno-os/utils (and plan9port), golang
%   (+elf linux + mach macos + pe windows + dwarf gdb),
%   kencc/9cc, +arm64, +riscv, 
%   9front
% - yet another fork, hmmm
%   but trying to incorporate all (golang Elf/Mach/PE, dwarf), latest
%   arm64/riscv, that can compile on arm64/amd64 (long vs int32),
%   that can cross-compile archs and OSes!

% - a self-supporting repo; embedded mk/rc/ed (better than inferno-os)
%   bootstrapped (better than kencc),
%   (and yacc?), Docker, GHA, good test suite with principia-softwarica
%   to check regressions
% - current state: 
% - future work: Mach-O, PE, multi-OS libc. Code is there
%   for Go, and actually part of goken9cc repo, but need to
%   remove go-specific and make real minilibc.

\section{Conclusion}

\end{document}
