\documentclass{article}
%CONFIG:
%\usepackage{fullpage}

\input{../../principia/docs/latex/Packages}

%alt: \input{../latex/Noweb}
\usepackage{../../principia/docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../../principia/docs/latex/syncweb}

\newif\iffinal\newif\ifverbose\newif\ifallcode
\input{../../principia/docs/latex/Macros}

\title{
\goken: The Plan 9 Toolchain Reborn
}
\author{
Yoann Padioleau\\
yoann.padioleau@gmail.com
}

\begin{document}
\date{}
\maketitle

\begin{abstract}
\goken is a work-in-progress project that aims to unify, in a single repository
(\url{https://github.com/aryx/goken9cc}),
the many improvements made to the original \plan toolchain.
The goal is to provide
assemblers, linkers, and C compilers for modern architectures, capable
of producing binaries not only for \plan but also Linux, macOS, and Windows.
\end{abstract}


\section{Introduction}

The \plan designers didn't just rethink from scratch the kernel;
they rethinked the whole operating system (OS) in a holistic manner.
%
In particular, the \plan assemblers, linkers, and C compilers, 
% with an 's' because many archs and separate progs
forming what is commonly called a {\em toolchain}, were also
written from scratch, by none other than Ken Thompson.
% and Rob pike for assemblers/linkers?
%
The design of this toolchain was also original with
the machine-code generation part shifted from the assembler to the linker,
%to factorize code? to simplify?
%% later though Rob Pike said it was maybe a mistake.
a C preprocessor embedded in the C compiler to speedup compilation time,
% also embedded in assembler
% cpp, a common complaint from Pike, leading later to Go
the support for numerous architectures (x86, Mips, ARM, Sparc, etc.),
and the ability to easily cross compile for those architectures
partly thanks to a clever naming scheme\footnote{
%alt:, and more?
In \plan, each architecture is assigned a character: x86 is '8', Mips
is 'v', ARM is '5', etc. To produce ARM binaries, one can simply
call [[5a]], the ARM assembler, to produce [[.5]] object
files (not [[.o]]), which can be linked by [[5l]], the ARM linker, to
produce a [[5.out]] binary (not [[a.out]]).
%
To produce x86 binaries use instead [[8a]] and [[8l]] in the same
directory without fear of overwriting the previous ARM object files
as this time the object files will use the [[.8]] extension.
}.
% (cross compiling, now popularized by ziglang).
% always supported by gcc, but never made easy (less needed too it's true)
%
In the following, I use the name {\em Kencc} to denote the set of 
assemblers, linkers, and C compilers supporting the many
architectures in the original \plan.

Kencc has a simple and very small codebase, which made
it very easy for other people to add support for more architectures.
% cite article, and people did add!
%said-later: Miller added, Forsity added
%
For example, the number of lines of code (LOC) of the ARM
assembler [[5a]] is 3600, the ARM linker [[5l]] is 7500 LOC, and the
C compiler [[5l]] with the architecture-independent code plus ARM-specific
code is only 18500 LOC. Thus, the whole ARM toolchain is less than 30000 LOC in total;
this is incredibly small compared to
the LOC of [[gcc]]/binutils or [[clang]]/LLVM.
% which are? only arm-xxx.c is 60000 ? and just arm-specific part,
% See Compiler.nw, Assembler.nw, and Linker.nw to put the LOC
% of ARM specific stuff

\section{Kencc after \plan}

After the 4th edition of \plan in 2000, Kencc continued to evolve slowly
in different repositories.
%alt: forks
%
Charles Forsyth added support for the arm64
architecture (architecture character '7'), which
powers all recent Apple machines as well as the Raspberry Pi 3 and 4.
%
Richard Miller added support for the RISC-V architecture,
both the 32 and 64 bits variants,
with respectively characters 'i' and 'j'.
% put dates? Miller in 2017?

The Inferno developers removed the use of \plan-specific C extensions
in the Kencc code in exchange for the ability to compile Kencc itself
using [[gcc]], 
% or [[clang]] but actually back in the day there was no clang
so one could install and use Kencc
on Linux, macOS, and Windows (but only to link \plan binaries).
% help for bootstrap


Finally, the Go designers, which include Rob Pike, designer of
\plan and author of the \plan assemblers and linkers, and
Ken Thompson, designer of \unix, \plan, and author of the \plan
C compilers, used and extended Kencc to write the 
original Go compiler.
%
Up until Go 1.3, the Go repository contained the C code of the
[[5a/5c/5l]] (ARM), [[8a/8c/8l]] (x86), and [[6a/6c/6l]] (amd64)
toolchains.
%
They extended Kencc to not only link \plan{} ([[a.out]]) binaries
but also Linux ([[Elf]]) binaries, macOS ([[Mach-O]]) binaries, and
even Windows ([[PE]]) binaries.
% also Dwarf GDB
%
They also developed a minimalist C and assembly library to interact
with the system calls of Linux, macOS, and Windows, so the Go
toolchain could produce Go binaries that could also run on those 3 OSes.
%Unfortunately disappeared, gradually got converted to Go.
% In fact hidden inside golang is this gem
% with multi-arch AND multi-os!! can cross compile on 386 Linux
% a macos amd64 binary! or windows! with minilibc! statically!
% (again now popularized with ziglang, golang).
% Sad because fantastic toolchain; actually I got trouble
% cross compiling xv6 on my machine with gcc/binutils!

\section{The \goken project}
% yet another fork, I like that :)

The goal of the new \goken project is to consolidate in a 
single repository
the many improvements made to the \plan toolchain over
the past two decades.
%
The \goken toolchain should
{\em cross-compile} for modern architectures (arm64, amd64, RISC-V),
{\em build} on those modern architectures, 
{\em build} on \plan but also Linux, macOS, and Windows, 
and finally {\em link} binaries that can run on those four OSes.
%
For example, you should be able to install \goken on an arm64 macOS 
machine and use it to produce binaries for a RISC-V Linux machine.

The goal is to provide a viable alternative to
[[gcc]]/binutils  and [[clang]]/LLVM with a
codebase that is only a fraction of their size.
%doable, the golang developers did it for Go!
% Lots of efforts on linker (mold, ...) but again time to go back
% to simplicity! and re-expose this hidden plan9 and inferno and golang gem!!
%useful for xv6! I had trouble to cross compile xv6 for x86 32 bits,
% or recently risc-V messy.

\section{Current state}

The \goken repository is alive at \url{https://github.com/aryx/goken9cc} and
has already a few interesting features.
%alt:\begin{itemize}
%\item
First, \goken contains the source of the MIPS, ARM, x86, and amd64 toolchains
from the original \plan, the arm64 toolchain
by Charles Forsyth, the RISC-V toolchain by Richard Miller, and 
the extensions by the Go Developers to support the Elf, Mach-O, and PE
binary formats as well as the [[gdb]] Dwarf debugging format.

Second, \goken contains also the source of a portable
minimal C library inspired from the [[lib9]] library in
plan9port\furl{https://9fans.github.io/plan9port/}
that allows to compile \plan source almost unchanged on mainstream OSes
(e.g., Linux, macOS). Finally, \goken includes also the source of Lex, Yacc,
the source of variants of [[mk]] and [[rc]] that can build
on POSIX OSes, and the source of a few utilities (e.g., [[ed]]).
% regexp, libbio
% self-sufficient

%\item
Third, \goken builds on Linux, macOS, and Windows,
% not plan9, not xv6, or tried?
using either [[gcc]] or [[clang]], 
% but not kencc? not self-hosted?
on ARM, arm64, x86, and amd64 machines.
% actually tested x86 and arm?
%
This was more difficult than anticipated because [[gcc]], as opposed
to the \plan C compiler, treats [[long]] as 64 bits on 64 bits machines;
the past assumption of the \plan authors though was that a [[long]] was always
32 bits, which required to change many globals and fields in
\goken from [[long]] to [[int32]] (but not all of them).

%item
Fourth, \goken requires just a C compiler, a linker, and a POSIX shell
(e.g., [[bash]]) to build. There is no need for Make or prebuilt binaries
of [[mk]] like in Inferno.
%
Instead, during the build process [[mk]] is first ``bootstrapped'' from
a POSIX shell script ([[build-mk.sh]]) that simply
runs in sequence a long list of commands to compile the source of 
the minimal C library, [[mk]], and [[rc]], without requiring the use
of [[mk]] or [[rc]].
%
The rest of the build process can then rely on the use of [[mk]] and
[[rc]] with many familiar [[mkfile]]s spread in the project.
%
There is no need like in Inferno to duplicate [[mkfiles]] to
support both [[rc]] and [[sh]], or to switch to [[Makefiles]]
like in Go 1.3.
% actually they moved away from Makefiles at some point
It just required to extend slightly [[mk]] to lookup for
an environment variable [[MKSHELL]] for the path to the shell
to invoke for recipes, and dynamically set this variable
with the path to [[rc]] built during the bootstrapping phase.

%\item
%dup: principia iwp9
Fifth, 
The whole build and packaging process for \goken
is succintely specified using Docker\footnote{See \url{https://www.docker.com/}
and \url{https://github.com/aryx/goken9cc/blob/master/Dockerfile}.
}.
%
Docker files are
a convenient and portable way to specify the commands to run
in a fresh environment to build a project.
%
Moreover, the Github continuous integration (CI) system
Github Actions\furl{https://github.com/features/actions}
can also run Docker containers; this is used
to automatically check for build and test regressions after each commit.

%\item
Finally, \goken can currently produce binaries for \plan, Linux, some old macOS,
for the amd64, ARM, and MIPS architectures,
for programs using only a few system calls
(e.g., [[open]], [[read]], [[write]], [[exit]], but you can do
already a lot with just those four system calls).

%\end{itemize}


\section{Future work}

Complete the matrix (host arch, host OS) x (target arch, target OS).
The code is there. Just need to connect things together and
adapt to latest formats, latest OSes.

% - future work: Mach-O, PE, multi-OS libc. Code is there
%   for Go, and actually part of goken9cc repo, but need to
%   remove go-specific and make real minilibc.


\end{document}
